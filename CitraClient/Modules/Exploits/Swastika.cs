using System;
using CitraClient.Modules.Base;
using UnhollowerBaseLib;
using UnityEngine;
using VRC;
using VRC.SDK3.Components;
using VRC.SDKBase;

namespace CitraClient.Modules.Exploits
{
	public class Swastika : ModuleBase
	{
		public static GameObject SphereObj;

		private static float _rotation;

		private static Vector3 _center;

		public static bool isFreeze = false;

		private static Il2CppArrayBase<VRC_Pickup> _il2CppArrayBase;

		private static float _moveSpeed;

		private static Rigidbody _swastikaRigidbody;

		public static float Speed = 1.5f;

		public static float Acceleration = 1f;

		private static readonly float _yaw = 0f;

		private static readonly float _pitch = 0f;

		public static bool isSwastikaControl = false;

		public static bool isSwastikaFollow;

		private static int _yOffset = 0;

		public static VRC.Player swastikaTargetPlayer = null;

		private static Vector3 _input;

		private static Vector3 Velocity { get; set; }

		private static void FindPickups()
		{
			_il2CppArrayBase = UnityEngine.Object.FindObjectsOfType<VRC_Pickup>();
		}

		public static void ToggleSwastikaControl()
		{
			isSwastikaControl = !isSwastikaControl;
			CreateSphereObj();
			if (!isSwastikaControl && SphereObj != null)
			{
				DestroySphereObj();
			}
		}

		public static void ToggleSwastikaFollow()
		{
			isSwastikaFollow = !isSwastikaFollow;
			CreateSphereObj();
			if (!isSwastikaFollow && SphereObj != null)
			{
				DestroySphereObj();
			}
		}

		public static void CreateSphereObj()
		{
			if (SphereObj != null)
			{
				UnityEngine.Object.Destroy(SphereObj);
			}
			GameObject gameObject = new GameObject("SPHERE_OBJ");
			gameObject.AddComponent<MeshFilter>();
			gameObject.AddComponent<MeshRenderer>();
			gameObject.AddComponent<VRCPickup>();
			gameObject.AddComponent<Rigidbody>();
			MeshFilter component = gameObject.GetComponent<MeshFilter>();
			MeshRenderer component2 = gameObject.GetComponent<MeshRenderer>();
			VRCPickup component3 = gameObject.GetComponent<VRCPickup>();
			Rigidbody component4 = gameObject.GetComponent<Rigidbody>();
			Il2CppArrayBase<Mesh> il2CppArrayBase = Resources.FindObjectsOfTypeAll<Mesh>();
			foreach (Mesh item in il2CppArrayBase)
			{
				if (item.name == "Sphere")
				{
					component.mesh = item;
				}
			}
			Material material = new Material(Shader.Find("Standard"));
			gameObject.GetComponent<MeshRenderer>().material.color = Color.red;
			component2.material = material;
			component4.mass = 0.9f;
			component4.drag = 0f;
			component4.useGravity = false;
			component4.angularDrag = 0.05f;
			component3.pickupable = true;
			component3.ThrowVelocityBoostMinSpeed = 3f;
			component3.AutoHold = VRC_Pickup.AutoHoldMode.Yes;
			gameObject.transform.localScale = new Vector3(0.05f, 0.05f, 0.05f);
			SphereObj = gameObject;
			Transform transform = VRCPlayer.field_Internal_Static_VRCPlayer_0.transform;
			Vector3 position = transform.position;
			SphereObj.transform.position = new Vector3(position.x, position.y + 1f, position.z);
			_swastikaRigidbody = SphereObj.GetComponent<Rigidbody>();
			_moveSpeed = 3f;
		}

		private static void UpdateSwastika()
		{
			if (!isSwastikaFollow)
			{
				return;
			}
			if (_rotation >= 360f)
			{
				_rotation = Time.deltaTime;
			}
			else
			{
				_rotation += Time.deltaTime;
			}
			short num = Convert.ToInt16(_il2CppArrayBase.Count / 8);
			float num2 = 0f;
			float num3 = 0f;
			float num4 = (float)_il2CppArrayBase.Count / 55f;
			foreach (VRC_Pickup item in _il2CppArrayBase)
			{
				if (!Networking.LocalPlayer.IsOwner(item.gameObject))
				{
					Networking.SetOwner(Networking.LocalPlayer, item.gameObject);
				}
				if (num2 >= (float)num)
				{
					if (num3 < 7f)
					{
						num3 += 1f;
						num2 = 0f;
					}
					else
					{
						num3 = 0f;
						num2 = 0f;
					}
				}
				if (SphereObj != null)
				{
					_center = SphereObj.transform.position;
				}
				Transform transform = item.transform;
				if (1 == 0)
				{
				}
				Vector3 position;
				if (num3 <= 2f)
				{
					if (num3 != 0f)
					{
						if (num3 != 1f)
						{
							if (num3 != 2f)
							{
								goto IL_034b;
							}
							position = _center + new Vector3((0f - Mathf.Cos(_rotation)) * num4 * (num2 / (float)num), 0f, Mathf.Sin(_rotation) * num4 * (num2 / (float)num));
						}
						else
						{
							position = _center + new Vector3(0f, (0f - num4) * (num2 / (float)num), 0f);
						}
					}
					else
					{
						position = _center + new Vector3(0f, num4 * (num2 / (float)num), 0f);
					}
				}
				else if (num3 <= 4f)
				{
					if (num3 != 3f)
					{
						if (num3 != 4f)
						{
							goto IL_034b;
						}
						position = _center + new Vector3((0f - Mathf.Cos(_rotation + 179f)) * num4, num4 * (num2 / (float)num), Mathf.Sin(_rotation + 179f) * num4);
					}
					else
					{
						position = _center + new Vector3((0f - Mathf.Cos(_rotation + 179f)) * num4 * (num2 / (float)num), 0f, Mathf.Sin(_rotation + 179f) * num4 * (num2 / (float)num));
					}
				}
				else if (num3 != 5f)
				{
					if (num3 != 6f)
					{
						goto IL_034b;
					}
					position = _center + new Vector3((0f - Mathf.Cos(_rotation + 179f)) * num4 * (num2 / (float)num), 0f - num4, Mathf.Sin(_rotation + 179f) * (num4 * (num2 / (float)num)));
				}
				else
				{
					position = _center + new Vector3((0f - Mathf.Cos(_rotation)) * num4, (0f - num4) * (num2 / (float)num), Mathf.Sin(_rotation) * num4);
				}
				goto IL_0387;
				IL_034b:
				position = _center + new Vector3((0f - Mathf.Cos(_rotation)) * num4 * (num2 / (float)num), num4, Mathf.Sin(_rotation) * num4 * (num2 / (float)num));
				goto IL_0387;
				IL_0387:
				if (1 == 0)
				{
				}
				transform.position = position;
				item.transform.rotation = Quaternion.Euler(0f, _rotation * -90f, 0f);
				if ((bool)item.GetComponent<Rigidbody>())
				{
					item.GetComponent<Rigidbody>().velocity = Vector3.zero;
				}
				num2 += 1f;
			}
		}

		private static void HandleSphereCardinalMovement()
		{
			Vector3 vector = default(Vector3);
			if (Input.GetKey(KeyCode.LeftArrow))
			{
				vector.x = -1f;
			}
			if (Input.GetKey(KeyCode.RightArrow))
			{
				vector.x = 1f;
			}
			if (Input.GetKey("q"))
			{
				vector.y = -1f;
			}
			if (Input.GetKey("e"))
			{
				vector.y = 1f;
			}
			if (Input.GetKey(KeyCode.DownArrow))
			{
				vector.z = -1f;
			}
			if (Input.GetKey(KeyCode.UpArrow))
			{
				vector.z = 1f;
			}
			_swastikaRigidbody.transform.rotation = Quaternion.Euler(_pitch, _yaw, 0f);
			if (vector.magnitude > 0f)
			{
				Velocity = Vector3.Lerp(Velocity, _swastikaRigidbody.transform.rotation * vector, Time.deltaTime * Acceleration);
			}
			if (isFreeze)
			{
				Velocity = Vector3.zero;
			}
			if (Input.GetKey("n"))
			{
				Velocity = Vector3.Lerp(Velocity, Vector3.zero, Time.deltaTime * Acceleration);
			}
			_swastikaRigidbody.transform.position += Velocity * (Time.deltaTime * Speed);
		}

		public static void HandleSphereFollowMovement()
		{
			if (swastikaTargetPlayer == null || _il2CppArrayBase == null || !isSwastikaFollow)
			{
				isSwastikaFollow = false;
			}
			else
			{
				_swastikaRigidbody.transform.position = Vector3.MoveTowards(_swastikaRigidbody.position, swastikaTargetPlayer.field_Private_VRCPlayerApi_0.GetBonePosition(HumanBodyBones.Head) + Vector3.up * 1.3f, Speed);
			}
		}

		public static void DestroySphereObj()
		{
			if (!(SphereObj == null))
			{
				UnityEngine.Object.Destroy(SphereObj.gameObject);
			}
		}

		public override void Update()
		{
			HandleSphereFollowMovement();
			UpdateSwastika();
		}

		public override void OnSceneLoad(int buildIndex, string sceneName)
		{
			FindPickups();
		}
	}
}
